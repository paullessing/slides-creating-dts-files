<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>I Hereby Declare</title>
  <link rel="stylesheet" href="node_modules/reveal.js/css/reveal.css">
  <link rel="stylesheet" href="node_modules/reveal.js/lib/css/zenburn.css">
  <link rel="stylesheet" href="assets/theme.css">
</head>
<body>
<div class="reveal">
  <div class="slides">

    <section class="center">
      <div class="content content--center">
        <h1>I Hereby<br />Declare</h1>
        <h2 style="text-align: center">Understanding Typescript Definition Files</h2>
      </div>
    </section>

    <!--<section hidden>-->
      <!--<h2>About Me</h2>-->
      <!--<ul class="content">-->
        <!--<li>Paul Lessing</li>-->
        <!--<li>City Pantry</li>-->
        <!--<li>Angular, Node, Java, PHP</li>-->
      <!--</ul>-->
    <!--</section>-->

    <section>
      <h2>What are <code>.d.ts</code> files?</h2>
      <ul class="content">
        <li>TypeScript <em>definition</em> files
          <ul>
            <li>C header files (<code>.h</code>)</li>
          </ul>
        </li>
        <li>Interface with JavaScript files</li>
        <li>Type Checking</li>
      </ul>
    </section>

    <section>
      <h2>Why do I care?</h2>
      <ul class="content">
        <li>Legacy code</li>
        <li>Migration</li>
        <li>Third-party Libraries</li>
        <li>Intellisense</li>
        <li>Publishing on npm</li>
        <li class="fragment">Applications for regular <code>.ts</code></li>
      </ul>

      <aside class="notes">
        Never publish <em>final code</em> as Typescript on npm - other people will not be able to compile it.
      </aside>
    </section>

    <section>
      <h2>Getting Started</h2>
      <ul class="content">
        <li><code>tsc -d &lt;file&gt;.ts</code></li>
      </ul>
      <div>
        <img src="assets/snippets/printer.ts.png" width="449" style="vertical-align: top">
        <img src="assets/snippets/printer.d.ts.png" width="396" style="vertical-align: top">
      </div>
    </section>

    <section>
      <h2>File Endings</h2>
      <div>
        <h3>.ts</h3>
        <ul class="content fragment">
          <li>Explicity imported</li>
          <li>Contains code and/or declarations</li>
        </ul>
      </div>
      <div>
        <h3>.d.ts</h3>
        <ul class="content fragment">
          <li>Automatically imported</li>
          <li>Imported <em>by name</em></li>
          <li><code>index.d.ts</code> in package.json</li>
          <li>Must <code>declare</code> everything at top level</li>
          <li>Is a <code>.ts</code> file - all the same rules apply</li>
          <li class="fragment">Use when dealing with external code</li>
        </ul>
      </div>
    </section>

    <section>
      <h2>The <code>declare</code> keyword</h2>
      <blockquote>
        The TypeScript <b>declare</b> keyword is used to declare variables that may not have originated from a TypeScript file.
      </blockquote>
      <ul>
        <li>All variables <em>inside</em> <code>.ts</code> files are either exported or invisible</li>
        <li>Global Scope</li>
        <li>Examples: jQuery <code>$</code>, Google Analytics <code>ga</code></li>
      </ul>
      <div class="fragment">
        <code>ga.js</code>
        <pre class="lang-js"><code>window.ga = ga || [];</code></pre>
      </div>
      <div class="fragment">
        <code>analytics.ts</code>
        <pre class="lang-ts"><code>ga.push('pageview');      // error TS2304: Cannot find name 'ga'.

declare const ga: string[];
ga.push('pageview');      // OK
</code></pre>
      </div>
    </section>

    <section>
      <h2>Concepts</h2>
      <ul class="content">
        <li>Type</li>
        <li>Value</li>
        <li>Namespace</li>
      </ul>
    </section>

    <section>
      <h2>Concepts: Types</h2>
      <ul class="content">
        <li><code><b>type</b> T = number | string</code></li>
        <li><code><b>interface</b> I { v: T }</code></li>
        <li><code><b>class</b> C {}</code></li>
        <li><code><b>enum</b> E { A, B, C }</code></li>
        <li><code>import { T } from 'm'</code></li>
      </ul>
      <aside class="notes">
        Things that are <em>interfaces</em>, compiled out by TypeScript
      </aside>
    </section>

    <section>
      <h2>Concepts: Values</h2>
      <ul class="content">
        <li><code><b>const</b> foo = 'bar' // let, var</code></li>
        <li><code><b>function</b> hello()</code></li>
        <li><code><b>enum</b> E { A, B, C }</code></li>
        <li><code><b>class</b> C {}</code></li>
        <li><code><b>namespace</b> n { const x }</code></li>
        <li><code><b>module</b> m { const x }</code></li>
        <li><code>import { <b>v</b> } from 'm' </code></li>
      </ul>

      <aside class="notes">
        Things that stay behind when you compile your code
      </aside>
    </section>

    <section>
      <h2>Namespaces</h2>
      <ul class="content">
        <li>
          <code>namespace N { interface I { v: T } }</code>
          <ul>
            <li><code>const x: A.B.C // Types</code></li>
            <li><code>const x = A.B.x // Values</code></li>
          </ul>
        </li>
      </ul>
    </section>

    <section>
      <h2>Both Value <em>and</em> Type</h2>
      <ul class="content">
        <li>
          Class
          <ul>
            <li>Interface</li>
            <li>Constructor function</li>
          </ul>
        </li>
        <li>
          Enum
          <ul>
            <li>Type</li>
            <li>Enum object</li>
            <!-- TODO maybe a code sample here? -->
          </ul>
        </li>
      </ul>
    </section>

    <section>
      <section>
        <h2>Module vs Namespace</h2>
        <h3><code>namespace</code></h3>
        <ul>
          <li>JavaScript Object</li>
          <li>Can export selectively from inside <code>namespace</code></li>
        </ul>
        <h3><code>module</code></h3>
        <ul>
          <li>Old name: "External Modules"</li>
          <li>Only <code>declare</code>d in <code>.d.ts</code> files</li>
          <li>1 <code>.ts</code> file = 1 <code>module</code></li>
        </ul>
      </section>
      <section>
        <div class="content content--center">
          <h2>Compiled output</h2>
          <img src="assets/snippets/namespace-module.png">
        </div>
      </section>
    </section>

    <section>
      <h2>So what does <em>this</em> mean?</h2>
      <img src="assets/snippets/refers-only-to-a-type.png" width="60%" style="vertical-align: top">
      <ul>
        <li class="fragment">
          We think <code>Promise</code> is a <em>class</em> (value), but the compiler only has an <em>interface</em> (type)
        </li>
        <li class="fragment">
          In this case: Ambient import vs. explicit import
        </li>
        <li class="fragment">
          We forgot to declare the right library in our <code>tsconfig.json</code>!
        </li>
      </ul>
    </section>

    <section>
      <section>
        <h2>Merging</h2>
        <ul class="content">
          <li>Overloading</li>
          <li>Multiple definitions as if they were one
            <pre><code class="lang-typescript">interface Foo { a: string; }
interface Foo { b: number; }

// Result
interface Foo {
  a: string;
  b: number;
}</code></pre>
          </li>
          <li class="fragment">Allows representing real-life JS library behaviour
            <pre><code class="lang-typescript">const now: moment.Moment = moment();

// Example declaration
namespace moment {
  interface Moment {}
}
function moment(): moment.Moment;</code></pre>
          </li>
          <li class="fragment">
            Can merge anything that doesn't cause a conflict
          </li>
        </ul>
      </section>

      <section>
        <h2>Merge Rules: Conflicts</h2>
        <ul class="content">
          <li>
            Different types for the same name
            <pre class="full"><code class="small lang-typescript">interface Foo { a: string; }
interface Foo { a: number; }

// Result
error TS2727: Subsequent property declarations must have the same type.
  Property 'a' must be of type 'string', but here has type 'number'.</code></pre>
          </li>
        </ul>
      </section>

      <section>
        <h2>Merge Rules: Conflicts</h2>
        <ul class="content">
          <li>
            Type aliases
            <pre class="full"><code class="small lang-typescript">type Direction = 'left';
type Direction = 'right';

// Result
error TS2300: Duplicate identifier 'Direction'.</code></pre>
          </li>
        </ul>
      </section>

      <section>
        <h2>Merge Rules: Conflicts</h2>
        <ul class="content">
          <li>
            Values
            <pre><code class="small lang-typescript">let Direction = 'left';
function Direction(): string;

// Result
error TS2300: Duplicate identifier 'Direction'.</code></pre>
          </li>
          <li class="fragment">
            Exception: namespaces
            <pre class="fragment"><code class="small lang-typescript">function time(): Date;
namespace time {
  const startOfTime: number = 0;
  now(): Date;
}</code></pre>
          </li>
          <li class="fragment">
            Namespaces never conflict
          </li>
        </ul>
      </section>
    </section>

    <section>
      <h2>Merge Rules: Namespaces</h2>
      <ul class="content">
        <li>
          Namespaces never conflict
          <ul>
            <li class="fragment">
              ...but the things inside them might (if they're exported)
            <pre class="fragment"><code class="lang-typescript">export namespace n {
  export interface F {
    a: string;
  }
}
export namespace n {
  export interface F {
    a: number;
  }
}

// Result
Subsequent property declarations must have the same type.
  Property 'a' must be of type 'string', but here has type 'number'.</code></pre>
            </li>
          </ul>
      </ul>
    </section>

    <section>
      <h2>Merge Rules: Exporting</h2>
      <ul>
        <li>
          All exported types and values are visible
        </li>
        <li>
          Exporting works from inside namespaces
        </li>
        <li>
          Non-exported values inside namespaces are "private"
        </li>
      </ul>
      <pre class="fragment lang-ts"><code>export namespace zoo {
  export interface Mammal { legs: number; }
  interface Dinosaur {}
}
export namespace zoo {
  export interface Mammal { furType: string; }
  export class Rabbit implements Mammal {
    legs: number;
    furType: string;
    friend: Dinosaur; // Error
  }
  export const bunny = new Rabbit();
}</code></pre>
    </section>

    <section>
      <h2>Example: Jasmine Matchers</h2>
      <pre class="lang-ts"><code>const testElement = fixture.debugElement.query(By.css('.test'));
expect(testElement).toBePresent();</code></pre>

      <pre class="lang-ts fragment"><code>jasmine.addMatchers({
  toBePresent: () => ({
    compare: (actual: DebugElement | null | void, message?: string) => {
      return {
        pass: !!actual,
        message: `Expected element ${ actual ? 'not ' : ''}to be present` +
          (message ? `: ${message}` : '')
      };
    }
  }),
};</code></pre>

      <pre class="lang-ts fragment"><code>declare namespace jasmine {
  export interface Matchers&lt;T&gt; {
    /**
     * Tests whether a given DebugElement is present in the DOM.
     * @param {string} message (optional) message to display on failure.
     */
    toBePresent(message?: string): boolean;
  }
}</code></pre>
    </section>

    <section>
      <section>
        <h2>Overloading: HTTP Matcher</h2>
        <img src="assets/snippets/overloaded-http-matcher.png" style="border: 0">
      </section>
      <section>
        <h2>Overloading: Intellisense</h2>
        <img src="assets/snippets/http-autocomplete.png" style="border: 0">
      </section>
    </section>

    <section>
      <section>
        <h2>Problem: String IDs</h2>
        <pre class="lang-ts"><code>interface Order {
  id: string;
  ...
}

class OrderService {
  getOrder(orderId: string): Order {}
}</code></pre>
        <ul class="fragment">
          <li>How to ensure correct call?</li>
          <li><code>string</code> could come from anywhere</li>
          <li><code>orderService.getOrder(customerId);</code></li>
        </ul>
      </section>

      <section>
        <h2>Pattern: Phantom Types</h2>
        <pre class="lang-ts"><code>interface Order {
  id: OrderId;
  ...
}
interface OrderId extends String {
  __order_id_phantom__: never;
}

class OrderService {
  getOrder(orderId: OrderId): Order {
    return this.http.get(`http://api.dev/orders/${orderId}`);
  }
}</code></pre>
        <ul>
          <li>Cannot assign to <code>never</code></li>
          <li><code>OrderId</code> is still a String</li>
          <li><b>But</b> no other string is an OrderId</li>
        </ul>
      </section>

      <section>
        <h2>Pattern: Phantom Types</h2>
        <pre class="lang-ts"><code>const orderId: string = router.queryParams.orderId;

orderService.getOrder(orderId); // error</code></pre>
        <pre class="lang-ts fragment"><code>function ensureOrderId(id: string): OrderId {
  if (!id || !id.match(ORDER_ID_PATTERN)) {
    throw new Error(`ID "${id}" does not look like a valid OrderId!`);
  }
  return id as OrderId;
}

const orderId: string = ensureOrderId(router.queryParams.orderId);
orderService.getOrder(orderId); // OK</code></pre>
      </section>
    </section>

    <section>
      <section>
        <h2>Example: <code>node-uuid</code></h2>
        <p>https://github.com/broofa/node-uuid</p>
        <h3>API</h3>
        <pre class="lang-plain"><code style="max-height: initial">uuid()
  Generates a v4 UUID.

uuid.v1([options [, buffer [, offset]]])
  Generate and return a RFC4122 v1 (timestamp-based) UUID.

uuid.v4([options [, buffer [, offset]]])
  Generate and return a RFC4122 v4 UUID.

  options - (Object)
    random - (Number[16]) Array of 16 numbers (0-255) to use instead of random ones
    rng - (Function) Random # generator to use.
        Set to one of the built-in generators:
          - uuid.mathRNG (all platforms),
          - uuid.nodeRNG (node.js only),
          - uuid.whatwgRNG (WebKit only),
          - custom function that returns an array[16] of byte values.
    buffer - (Array | Buffer) Array or buffer where UUID bytes are to be written.

  offset - (Number) Starting index in buffer at which to begin writing.</code></pre>
      </section>

      <section>
        <pre class="lang-ts"><code>function uuid(): string;</code></pre>
        <pre class="lang-ts fragment"><code>function uuid(): typeof uuid.v4;

namespace uuid {
  function v1(): string;
  function v4(): string;
}</code></pre>
      </section>

      <section>
        <pre class="lang-ts"><code>function uuid(): string;
namespace uuid {
  // Placeholders until we figure them out
  type Rng = any;
  type OutputBuffer = any;

  interface V4Options {
    random?: number[];
    rng?: Rng;
    buffer?: OutputBuffer;
  }

  function v1(): string;
  function v4(
    options?: V4Options,
    buffer?: OutputBuffer,
    offset?: number
  ): string | OutputBuffer;
}</code></pre>
      </section>

      <section>
        <pre class="lang-ts"><code style="max-height: initial;">/// &lt;reference types="node" /&gt;
// Imports all types from @types/node/index.d.ts

function uuid(): string;
namespace uuid {
  type Rng = any;
  type OutputBuffer = number[] | Buffer; // Imported from node

  interface V4Options {
    random?: number[];
    rng?: Rng;
    buffer?: OutputBuffer;
  }

  function v1(): string;
  function v4(
    options?: V4Options,
    buffer?: OutputBuffer,
    offset?: number
  ): string | OutputBuffer;
}</code></pre>
      </section>

      <section>
        <pre class="lang-ts"><code style="max-height: initial;">/// &lt;reference types="node" /&gt;

function uuid(): string;
namespace uuid {
  type Rng = any;
  type OutputBuffer = number[] | Buffer;

  interface V4Options {
    random?: number[];
    rng?: Rng;
  }
  interface V4WithBufferOptions extends V4Options {
    buffer: OutputBuffer;
  }

  function v1(): string;

  function v4(options?: V4Options): string;
  function v4(options: V4WithBufferOptions): OutputBuffer;
  function v4(options: V4Options, buffer: OutputBuffer, offset?: number): OutputBuffer;
}</code></pre>
      </section>

      <section>
        <pre class="lang-ts"><code style="max-height: initial;">/// &lt;reference types="node" /&gt;

function uuid(): string;
namespace uuid {
  type Rng = any;
  type OutputBuffer = number[] | Buffer;

  interface V4Options {
    random?: number[];
    rng?: Rng;
  }
  interface V4WithBufferOptions&lt;T extends OutputBuffer&gt; extends V4Options {
    buffer: T;
  }

  function v1(): string;

  function v4(options?: V4Options): string;
  function v4&lt;T extends OutputBuffer&gt;(options: V4WithBufferOptions&lt;T&gt;): T;
  unction v4&lt;T extends OutputBuffer&gt;(options: V4Options, buffer: T, offset?: number): T;
}</code></pre>
      </section>

      <section>
        <pre class="lang-ts"><code style="max-height: initial;">/// &lt;reference types="node" /&gt;

const uuid: typeof uuid.v4;
namespace uuid {
  interface ProvidedRng {
    __internal_rng_phantom__: never;
  }
  const mathRNG: ProvidedRng;
  const nodeRNG: ProvidedRng;
  const whatwgRNG: ProvidedRng;
  interface CustomRng { (): number[] } // Returns number[16];

  type Rng = ProvidedRng | CustomRng;
  type OutputBuffer = number[] | Buffer;

  interface V4Options {
    random?: number[];
    rng?: Rng;
  }
  interface V4WithBufferOptions&lt;T extends OutputBuffer&gt; extends V4Options {
    buffer: T;
  }

  function v1(): string;

  function v4(options?: V4Options): string;
  function v4&lt;T extends OutputBuffer&gt;(options: V4WithBufferOptions&lt;T&gt;): T;
  function v4&lt;T extends OutputBuffer&gt;(options: V4Options, buffer: T, offset?: number): T;
}

export = uuid;</code></pre>
      </section>

      <section>
        <h2>Result</h2>
        <img src="assets/snippets/uuid.png">
      </section>
    </section>

    <section>
      <h2>@types / DefinitelyTyped</h2>
      <ul>
        <li>https://github.com/DefinitelyTyped/DefinitelyTyped</li>
        <li><code>yarn add -D @types/&lt;package&gt;</code></li>
      </ul>
    </section>
  </div>
</div>

<script src="node_modules/reveal.js/lib/js/head.min.js"></script>
<script src="node_modules/reveal.js/js/reveal.js"></script>
<!--<script src="node_modules/reveal.js/plugin/highlight/highlight.js"></script>-->
<script src="node_modules/reveal.js/plugin/notes/notes.js"></script>
<script>
  Reveal.initialize({
    progress: true,
    controls: true,
    history: true,
    center: false,
    dependencies: [
      { src: 'node_modules/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    ]
  });
</script>
<script>
  document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>')
</script>
</body>
</html>
