<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Creating .d.ts Files</title>
  <link rel="stylesheet" href="node_modules/reveal.js/css/reveal.css">
  <link rel="stylesheet" href="node_modules/reveal.js/lib/css/zenburn.css">
  <link rel="stylesheet" href="assets/theme.css">
</head>
<body>
<div class="reveal">
  <div class="slides">

    <section class="center">
      <div class="content content--center">
        <h1>I Hereby<br />Declare</h1>
        <h2 style="text-align: center">Understanding Typescript Definition Files</h2>
      </div>
    </section>

    <!--<section hidden>-->
      <!--<h2>About Me</h2>-->
      <!--<ul class="content">-->
        <!--<li>Paul Lessing</li>-->
        <!--<li>City Pantry</li>-->
        <!--<li>Angular, Node, Java, PHP</li>-->
      <!--</ul>-->
    <!--</section>-->

    <section>
      <h2>What are <code>.d.ts</code> files?</h2>
      <ul class="content">
        <li>TypeScript <em>definition</em> files
          <ul>
            <li>C header files (<code>.h</code>)</li>
          </ul>
        </li>
        <li>Interface with JavaScript files</li>
        <li>Type Checking</li>
      </ul>
    </section>

    <section>
      <h2>Why do I care?</h2>
      <ul class="content">
        <li>Legacy code</li>
        <li>Migration</li>
        <li>Third-party Libraries</li>
        <li>Intellisense</li>
        <li>Publishing on npm</li>
      </ul>

      <aside class="notes">
        Never publish <em>final code</em> as Typescript on npm - other people will not be able to compile it.
      </aside>
    </section>

    <section>
      <h2>Getting Started</h2>
      <ul class="content">
        <li><code>tsc -d &lt;file&gt;.ts</code></li>
      </ul>
      <div>
        <img src="assets/snippets/printer.ts.png" width="449" style="vertical-align: top">
        <img src="assets/snippets/printer.d.ts.png" width="396" style="vertical-align: top">
      </div>
      <div>
      </div>
    </section>

    <section>
      <h2>Concepts</h2>
      <ul class="content">
        <li>Type</li>
        <li>Value</li>
        <li>Namespace</li>
      </ul>
    </section>

    <section>
      <h2>Concepts: Types</h2>
      <ul class="content">
        <li><code><b>type</b> T = number | string</code></li>
        <li><code><b>interface</b> I { v: T }</code></li>
        <li><code><b>class</b> C {}</code></li>
        <li><code><b>enum</b> E { A, B, C }</code></li>
        <li><code>import { T } from 'm'</code></li>
      </ul>
      <aside class="notes">
        Things that are <em>interfaces</em>, compiled out by TypeScript
      </aside>
    </section>

    <section>
      <h2>Concepts: Values</h2>
      <ul class="content">
        <li><code><b>const</b> foo = 'bar' // let, var</code></li>
        <li><code><b>function</b> hello()</code></li>
        <li><code><b>enum</b> E { A, B, C }</code></li>
        <li><code><b>class</b> C {}</code></li>
        <li><code><b>namespace</b> n { const x }</code></li>
        <li><code><b>module</b> m { const x }</code></li>
        <li><code>import { <b>v</b> } from 'm' </code></li>
      </ul>

      <aside class="notes">
        Things that stay behind when you compile your code
      </aside>
    </section>

    <section>
      <h2>Namespaces</h2>
      <ul class="content">
        <li>
          <code>namespace N { interface I { v: T } }</code>
          <ul>
            <li><code>const x: A.B.C // Types</code></li>
            <li><code>const x = A.B.x // Values</code></li>
          </ul>
        </li>
      </ul>
    </section>

    <section>
      <h2>Both Value <em>and</em> Type</h2>
      <ul class="content">
        <li>
          Class
          <ul>
            <li>Interface</li>
            <li>Constructor function</li>
          </ul>
        </li>
        <li>
          Enum
          <ul>
            <li>Type</li>
            <li>Enum object</li>
            <!-- TODO maybe a code sample here? -->
          </ul>
        </li>
      </ul>
    </section>

    <section>
      <h2>So what does <em>this</em> mean?</h2>
      <img src="assets/snippets/refers-only-to-a-type.png" width="60%" style="vertical-align: top">
      <ul>
        <li class="fragment">
          We think <code>Promise</code> is a <em>class</em> (value), but the compiler only has an <em>interface</em> (type)
        </li>
        <li class="fragment">
          In this case: Ambient import vs. explicit import
        </li>
        <li class="fragment">
          We forgot to declare the right library in our <code>tsconfig.json</code>!
        </li>
      </ul>
    </section>

    <section>
      <h2>Merging</h2>
      <ul class="content">
        <li>Overloading</li>
        <li>Multiple definitions as if they were one
          <pre><code class="lang-typescript">interface Foo { a: string; }
interface Foo { b: number; }

// Result
interface Foo {
  a: string;
  b: number;
}</code></pre>
        </li>
        <li class="fragment">Allows representing real-life JS library behaviour
          <pre><code class="lang-typescript">const now: moment.Moment = moment();

// Example declaration
namespace moment {
  interface Moment {}
}
function moment(): moment.Moment;</code></pre>
        </li>
      </ul>
    </section>

    <section>
      <section>
        <h2>Merge Rules</h2>
        <ul>
          <li>
            Can merge anything that doesn't cause a conflict
          </li>
        </ul>
      </section>

      <section>
        <h2>Merge Rules: Conflicts</h2>
        <ul class="content">
          <li>
            Different types for the same name
            <pre class="full"><code class="small lang-typescript">interface Foo { a: string; }
interface Foo { a: number; }

// Result
error TS2727: Subsequent property declarations must have the same type.
  Property 'a' must be of type 'string', but here has type 'number'.</code></pre>
          </li>
        </ul>
      </section>

      <section>
        <h2>Merge Rules: Conflicts</h2>
        <ul class="content">
          <li>
            Type aliases
            <pre class="full"><code class="small lang-typescript">type Direction = 'left';
type Direction = 'right';

// Result
error TS2300: Duplicate identifier 'Direction'.</code></pre>
          </li>
        </ul>
      </section>

      <section>
        <h2>Merge Rules: Conflicts</h2>
        <ul class="content">
          <li>
            Values
            <pre><code class="small lang-typescript">let Direction = 'left';
function Direction(): string;

// Result
error TS2300: Duplicate identifier 'Direction'.</code></pre>
          </li>
          <li class="fragment">
            Exception: namespaces
            <pre class="fragment"><code class="small lang-typescript">function time(): Date;
namespace time {
  const startOfTime: number = 0;
  now(): Date;
}</code></pre>
          </li>
          <li class="fragment">
            Namespaces never conflict
          </li>
        </ul>
      </section>
    </section>

    <section>
      <h2>Merge Rules: Namespaces</h2>
      <ul class="content">
        <li>
          Namespaces never conflict
          <ul>
            <li class="fragment">
              ...but the things inside them might (if they're exported)
            <pre class="fragment"><code class="lang-typescript">export namespace n {
  export interface F {
    a: string;
  }
}
export namespace n {
  export interface F {
    a: number;
  }
}

// Result
Subsequent property declarations must have the same type.
  Property 'a' must be of type 'string', but here has type 'number'.</code></pre>
            </li>
          </ul>
      </ul>
    </section>

    <section>
      <h2>Merge Rules: Exporting</h2>
      <ul>
        <li>
          All exported types and values are visible
        </li>
        <li>
          Exporting works from inside namespaces
        </li>
        <li>
          Non-exported values inside namespaces are "private"
        </li>
      </ul>
      <pre class="fragment lang-ts"><code>namespace zoo {
  export interface Mammal { legs: number; }
  interface Dinosaur {}
}
namespace zoo {
  export interface Mammal { furType: string; }
  export class Rabbit implements Mammal {
    legs: number;
    furType: string;
    friend: Dinosaur; // Error
  }
  export const bunny = new Rabbit();
}</code></pre>
    </section>

    <section>
      <h2>Difference between <code>.d.ts</code> and <code>.ts</code></h2>
    </section>

    <section>
      <h2>What is <code>declare</code>?</h2>
    </section>

    <section>
      <h2>Example: Jasmine Matchers</h2>
      <pre class="lang-ts"><code>const testElement = fixture.debugElement.query(By.css('.test'));
expect(testElement).toBePresent();</code></pre>

      <pre class="lang-ts fragment"><code>jasmine.addMatchers({
  toBePresent: () => ({
    compare: (actual: DebugElement | null | void, message?: string) => {
      return {
        pass: !!actual,
        message: `Expected element ${ actual ? 'not ' : ''}to be present` +
          (message ? `: ${message}` : '')
      };
    }
  }),
};</code></pre>

      <pre class="lang-ts fragment"><code>declare namespace jasmine {
  export interface Matchers&lt;T&gt; {
    /**
     * Tests whether a given DebugElement is present in the DOM.
     * @param {string} message (optional) message to display on failure.
     */
    toBePresent(message?: string): boolean;
  }
}</code></pre>
    </section>

    <section>
      <h2>Tools: Type Unions</h2>
      <pre class="lang-ts"><code>type Direction = 'right' | 'left';</code></pre>
    </section>

    <section>
      <h2>Problem: String IDs</h2>
      <pre class="lang-ts"><code>interface Order {
  id: string;
  ...
}

class OrderService {
  getOrder(orderId: string): Order {}
}</code></pre>
      <ul class="fragment">
        <li>How to ensure correct call?</li>
        <li><code>string</code> could come from anywhere</li>
        <li><code>orderService.getOrder(customerId);</code></li>
      </ul>
    </section>

    <section>
      <h2>Pattern: Phantom Types</h2>
      <pre class="lang-ts"><code>interface Order {
  id: OrderId;
  ...
}
interface OrderId extends String {
  __order_id_phantom__: never;
}

class OrderService {
  getOrder(orderId: OrderId): Order {}
}</code></pre>
      <ul>
        <li>Cannot assign to <code>never</code></li>
        <li><code>OrderId</code> is still a String</li>
        <li><b>But</b> no other string is an OrderId</li>
      </ul>
    </section>

    <!-- Slides that need to appear -->

    <section>
      <h2>@types / DefinitelyTyped</h2>
    </section>

  </div>
</div>

<div class="display: none">
  TODO

  declare var Sinon: Sinon.SinonStatic;

  export = Sinon;
  export as namespace sinon;
</div>

<script src="node_modules/reveal.js/lib/js/head.min.js"></script>
<script src="node_modules/reveal.js/js/reveal.js"></script>
<!--<script src="node_modules/reveal.js/plugin/highlight/highlight.js"></script>-->
<script src="node_modules/reveal.js/plugin/notes/notes.js"></script>
<script>
  Reveal.initialize({
    progress: false,
    controls: false,
    history: true,
    center: false,
    dependencies: [
      { src: 'node_modules/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    ]
  });
</script>
<script>
  document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>')
</script>
</body>
</html>
